import pytest
from numbers_parsing import *
from numbers_parsing.numbers_logic import _parse_fractional_part


@pytest.mark.parametrize("input_value, expected_output", [
    # Тесты для целых чисел
    ('ноль', 0),
    ('один', 1),
    ('десять', 10),
    ('пятнадцать', 15),
    ('двадцать', 20),
    ('двадцать пять', 25),
    ('сорок два', 42),
    ('девяносто девять', 99),
    ('сто', 100),
    ('сто один', 101),
    ('сто десять', 110),
    ('сто пятнадцать', 115),
    ('сто девяносто девять', 199),
    ('триста сорок два', 342),
    ('девятьсот девяносто девять', 999),
    ('одна тысяча', 1000),
    ('одна тысяча один', 1001),
    ('одна тысяча десять', 1010),
    ('одна тысяча сто', 1100),
    ('одна тысяча сто пятнадцать', 1115),
    ('две тысячи', 2000),
    ('две тысячи двадцать пять', 2025),
    ('десять тысяч', 10000),
    ('двадцать одна тысяча', 21000),
    ('девятьсот девяносто девять тысяч девятьсот девяносто девять', 999999),
    ('один миллион', 1000000),
    ('один миллион один', 1000001),
    ('один миллион сто', 1000100),
    ('один миллион сто тысяч', 1100000),
    ('девятьсот девяносто девять миллионов девятьсот девяносто девять тысяч девятьсот девяносто девять', 999999999),
    ('минус один', -1),
    ('минус пятьдесят два', -52),
    ('минус одна тысяча', -1000),
    ('минус один миллион', -1000000),
    # Тесты для положительных дробных чисел
    ('сорок один и тридцать одна сотая', 41.31),
    ('девятнадцать и восемьдесят две сотых', 19.82),
    ('двадцать пять и семь десятых', 25.7),
    ('три и одна тысячная', 3.001),
    ('ноль и пять тысячных', 0.005),
    ('сорок один и сорок одна тысячная', 41.041),
    ('сто пятьдесят два и три сотых', 152.03),
    ('двести и двести двадцать пять тысячных', 200.225),
    ('тринадцать и семь сотых', 13.07),
    # Тесты для отрицательных дробных чисел
    ('минус один и пять десятых', -1.5),
    ('минус пятьдесят и девять десятых', -50.9),
])
def test_parse_word_to_number(input_value, expected_output) -> None:
    result = parse_word_to_number(input_value)
    if isinstance(expected_output, float):
        assert pytest.approx(result, 0.0001) == expected_output
    else:
        assert result == expected_output


@pytest.mark.parametrize("input_value, expected_output", [
    # Тесты для целых чисел
    (0, 'ноль'),
    (1, 'один'),
    (10, 'десять'),
    (15, 'пятнадцать'),
    (20, 'двадцать'),
    (25, 'двадцать пять'),
    (42, 'сорок два'),
    (99, 'девяносто девять'),
    (100, 'сто'),
    (101, 'сто один'),
    (110, 'сто десять'),
    (115, 'сто пятнадцать'),
    (199, 'сто девяносто девять'),
    (342, 'триста сорок два'),
    (999, 'девятьсот девяносто девять'),
    (1000, 'одна тысяча'),
    (1001, 'одна тысяча один'),
    (1010, 'одна тысяча десять'),
    (1100, 'одна тысяча сто'),
    (1115, 'одна тысяча сто пятнадцать'),
    (2000, 'две тысячи'),
    (2025, 'две тысячи двадцать пять'),
    (10000, 'десять тысяч'),
    (21000, 'двадцать одна тысяча'),
    (999999, 'девятьсот девяносто девять тысяч девятьсот девяносто девять'),
    (1000000, 'один миллион'),
    (1000001, 'один миллион один'),
    (1000100, 'один миллион сто'),
    (1100000, 'один миллион сто тысяч'),
    (999999999, 'девятьсот девяносто девять миллионов девятьсот девяносто девять тысяч девятьсот девяносто девять'),
    (-1, 'минус один'),
    (-52, 'минус пятьдесят два'),
    (-1000, 'минус одна тысяча'),
    (-1000000, 'минус один миллион'),
    # Тесты для положительных дробных чисел
    (41.31, 'сорок один и тридцать одна сотая'),
    (19.82, 'девятнадцать и восемьдесят две сотых'),
    (25.7, 'двадцать пять и семь десятых'),
    (3.001, 'три и одна тысячная'),
    (0.005, 'ноль и пять тысячных'),
    (41.041, 'сорок один и сорок одна тысячная'),
    (152.03, 'сто пятьдесят два и три сотых'),
    (200.225, 'двести и двести двадцать пять тысячных'),
    (13.07, 'тринадцать и семь сотых'),
    # Тесты для отрицательных дробных чисел
    (-1.5, 'минус один и пять десятых'),
    (-50.9, 'минус пятьдесят и девять десятых'),
])
def test_parse_number_to_word(input_value, expected_output) -> None:
    result = parse_number_to_word(input_value)
    assert result == expected_output


@pytest.mark.parametrize("input_value, expected_output", [
    # Тесты для дробной части
    (0.31, ['тридцать', 'одна', 'сотая']),
    (0.82, ['восемьдесят', 'две', 'сотых']),
    (0.7, ['семь', 'десятых']),
    (0.001, ['одна', 'тысячная']),
    (0.005, ['пять', 'тысячных']),
    (0.5, ['пять', 'десятых']),
    (0.041, ['сорок', 'одна', 'тысячная']),
    (0.41, ['сорок', 'одна', 'сотая']),
    (0.401, ['четыреста', 'одна', 'тысячная']),
    (0.03, ['три', 'сотых']),
    (0.225, ['двести', 'двадцать', 'пять', 'тысячных']),
    (0.07, ['семь', 'сотых']),
    (0.9, ['девять', 'десятых']),
])
def test_parse_fractional_part(input_value, expected_output) -> None:
    result = _parse_fractional_part(input_value)
    assert result == expected_output
